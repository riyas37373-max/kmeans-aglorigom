# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ROLYlIQMl_OCAt3MPQil2-xVfMgaD6g3
"""

import numpy as np
from sklearn.datasets import make_blobs

def generate_data(
    n_samples=500,
    centers=4,
    cluster_std=(1.0, 2.5, 1.5, 3.0),
    random_state=42
):
    X, y_true = make_blobs(
        n_samples=n_samples,
        centers=centers,
        cluster_std=cluster_std,
        random_state=random_state
    )
    return X, y_true

if __name__ == "__main__":
    X, y = generate_data()
    print("Data shape:", X.shape)

import numpy as np
from sklearn.datasets import make_blobs # Added for generate_data

def generate_data(
    n_samples=500,
    centers=4,
    cluster_std=(1.0, 2.5, 1.5, 3.0),
    random_state=42
):
    X, y_true = make_blobs(
        n_samples=n_samples,
        centers=centers,
        cluster_std=cluster_std,
        random_state=random_state
    )
    return X, y_true

def initialize_centroids(X, k, random_state=42):
    rng = np.random.RandomState(random_state)
    indices = rng.choice(len(X), size=k, replace=False)
    return X[indices].astype(float)

def compute_distances(X, centroids):
    diff = X[:, np.newaxis, :] - centroids[np.newaxis, :, :]
    dists = np.sum(diff ** 2, axis=2)
    return dists

def assign_clusters(X, centroids):
    dists = compute_distances(X, centroids)
    labels = np.argmin(dists, axis=1)
    return labels

def update_centroids(X, labels, k):
    n_features = X.shape[1]
    centroids = np.zeros((k, n_features))
    for i in range(k):
        cluster_points = X[labels == i]
        if len(cluster_points) == 0:
            centroids[i] = X[np.random.randint(0, len(X))]
        else:
            centroids[i] = cluster_points.mean(axis=0)
    return centroids

def compute_inertia(X, centroids, labels):
    dists = compute_distances(X, centroids)
    chosen = dists[np.arange(len(X)), labels]
    return np.sum(chosen)

def kmeans(X, k, max_iters=100, tol=1e-4, random_state=42):
    centroids = initialize_centroids(X, k, random_state=random_state)
    for _ in range(max_iters):
        labels = assign_clusters(X, centroids)
        new_centroids = update_centroids(X, labels, k)
        shift = np.linalg.norm(new_centroids - centroids)
        centroids = new_centroids
        if shift < tol:
            break
    inertia = compute_inertia(X, centroids, labels)
    return centroids, labels, inertia

if __name__ == "__main__":
    # Removed 'from data_generation import generate_data'
    X, y = generate_data() # Now uses the function defined in this cell
    c, l, iner = kmeans(X, k=4)
    print("Final inertia:", iner)
    print("Centroids:\n", c)

import numpy as np
from sklearn.datasets import make_blobs

def generate_data(
    n_samples=500,
    centers=4,
    cluster_std=(1.0, 2.5, 1.5, 3.0),
    random_state=42
):
    X, y_true = make_blobs(
        n_samples=n_samples,
        centers=centers,
        cluster_std=cluster_std,
        random_state=random_state
    )
    return X, y_true

def initialize_centroids(X, k, random_state=42):
    rng = np.random.RandomState(random_state)
    indices = rng.choice(len(X), size=k, replace=False)
    return X[indices].astype(float)

def compute_distances(X, centroids):
    diff = X[:, np.newaxis, :] - centroids[np.newaxis, :, :]
    dists = np.sum(diff ** 2, axis=2)
    return dists

def assign_clusters(X, centroids):
    dists = compute_distances(X, centroids)
    labels = np.argmin(dists, axis=1)
    return labels

def update_centroids(X, labels, k):
    n_features = X.shape[1]
    centroids = np.zeros((k, n_features))
    for i in range(k):
        cluster_points = X[labels == i]
        if len(cluster_points) == 0:
            centroids[i] = X[np.random.randint(0, len(X))]
        else:
            centroids[i] = cluster_points.mean(axis=0)
    return centroids

def compute_inertia(X, centroids, labels):
    dists = compute_distances(X, centroids)
    chosen = dists[np.arange(len(X)), labels]
    return np.sum(chosen)

def kmeans(X, k, max_iters=100, tol=1e-4, random_state=42):
    centroids = initialize_centroids(X, k, random_state=random_state)
    for _ in range(max_iters):
        labels = assign_clusters(X, centroids)
        new_centroids = update_centroids(X, labels, k)
        shift = np.linalg.norm(new_centroids - centroids)
        centroids = new_centroids
        if shift < tol:
            break
    inertia = compute_inertia(X, centroids, labels)
    return centroids, labels, inertia

def run_elbow(k_min=1, k_max=10):
    X, y_true = generate_data()
    Ks = range(k_min, k_max + 1)
    inertias = []

    for k in Ks:
        centroids, labels, inertia = kmeans(X, k)
        inertias.append(inertia)
        print(f"K = {k}, inertia = {inertia:.2f}")

    return Ks, inertias

if __name__ == "__main__":
    # Test data generation and run elbow method
    X_test, y_test = generate_data()
    print("Generated data shape:", X_test.shape)
    Ks, inertias = run_elbow()
    print("Ks:", list(Ks))
    print("Inertias:", inertias)