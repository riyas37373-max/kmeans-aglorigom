# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ROLYlIQMl_OCAt3MPQil2-xVfMgaD6g3
"""

import numpy as np

def initialize_centroids(X, k, random_state=42):
    rng = np.random.RandomState(random_state)
    indices = rng.choice(len(X), size=k, replace=False)
    return X[indices].astype(float)

def compute_distances(X, centroids):
    diff = X[:, np.newaxis, :] - centroids[np.newaxis, :, :]
    dists = np.sum(diff ** 2, axis=2)
    return dists

def assign_clusters(X, centroids):
    dists = compute_distances(X, centroids)
    labels = np.argmin(dists, axis=1)
    return labels

def update_centroids(X, labels, k):
    n_features = X.shape[1]
    centroids = np.zeros((k, n_features))
    for i in range(k):
        cluster_points = X[labels == i]
        if len(cluster_points) == 0:
            # If a cluster becomes empty, reinitialize its centroid randomly
            centroids[i] = X[np.random.randint(0, len(X))]
        else:
            centroids[i] = cluster_points.mean(axis=0)
    return centroids

def compute_inertia(X, centroids, labels):
    dists = compute_distances(X, centroids)
    # Select the distance to the assigned centroid for each point
    chosen = dists[np.arange(len(X)), labels]
    return np.sum(chosen)

def kmeans(X, k, max_iters=100, tol=1e-4, random_state=42):
    centroids = initialize_centroids(X, k, random_state=random_state)
    for _ in range(max_iters):
        labels = assign_clusters(X, centroids)
        new_centroids = update_centroids(X, labels, k)
        # Calculate the shift in centroids to check for convergence
        shift = np.linalg.norm(new_centroids - centroids)
        centroids = new_centroids
        if shift < tol:
            break
    inertia = compute_inertia(X, centroids, labels)
    return centroids, labels, inertia

# Define a generate_data function to provide sample data for K-Means
def generate_data(n_samples=300, n_features=2, centers=4, cluster_std=1.0, random_state=42):
    rng = np.random.RandomState(random_state)
    X = []
    y = [] # True labels, not used by kmeans, but good for generation
    for i in range(centers):
        # Randomly choose center for each cluster within a range
        center = rng.uniform(-10, 10, n_features)
        # Generate points around the center with some standard deviation
        cluster_data = rng.normal(loc=center, scale=cluster_std, size=(n_samples // centers, n_features))
        X.append(cluster_data)
        y.extend([i] * (n_samples // centers))
    return np.vstack(X), np.array(y)

if __name__ == "__main__":
    # Use the newly defined generate_data function
    X, y = generate_data(n_samples=400, centers=4, cluster_std=1.5, random_state=42)
    c, l, iner = kmeans(X, k=4)
    print("Final inertia:", iner)
    print("Centroids:\n", c)